/* global tinycolor */

<colorwheel>
    <img id="colorwheel" ref="colorwheel" src="res/colorwheel.png" width="auto"
        height="90%" onload="{imageLoaded}" />

    <div class="touchrect" id="touchrect"></div>

    <div id="pointerT" ref="pointerT"
        style="left: {pointerTLeft}px; top: {pointerTTop}px;">
        <svg height="50" width="50">
            <polygon id="pointerTinner" points="25,0 0,43.4 50,43.4"
                style="stroke: {pointerTColor}" />
        </svg>
    </div>
    <div id="pointerO" ref="pointerO"
        style="left: {pointerOLeft}px; top: {pointerOTop}px; border-color: {pointerOColor};">
    </div>
    <div id="pointerX" ref="pointerX"
        style="left: {pointerXLeft}px; top: {pointerXTop}px;">
        <svg id="pointerXinner" height="50" width="50">
            <polygon id="pointerXinner"
                points="10,0 0,10 15,25 0,40 10,50 25,35 40,50 50,40 35,25 50,10 40,0 25,15"
                style="stroke: {pointerXColor};" />
        </svg>
    </div>
    <div id="pointerS" ref="pointerS"
        style="left: {pointerSLeft}px; top: {pointerSTop}px; border-color: {pointerSColor};">
    </div>

    <div class="wrapper_msg invisible">
        <div ref="message"></div>
    </div>

    <script>
        var self = this;
        self.color = new Array(4).fill(new tinycolor(opts.color));
        self.actualPointer = -1;

        self.setColor = function (pointer, color) {
            self.color[pointer] = new tinycolor(color);
            if (self.isMounted) {
                self.update();
            }
        };

        self.on('update', function () {
            for (var i = 0; i <= 3; i++)
                updatePointer(i);
        });

        self.on('mount', function () {
            var pointerS = self.root.querySelector('#pointerS');
            var pointerT = self.root.querySelector('#pointerTinner');
            var pointerO = self.root.querySelector('#pointerO');
            var pointerX = self.root.querySelector('#pointerXinner');
            var touchrect = self.root.querySelector('.touchrect');
            addHandlers(pointerS);
            addHandlers(pointerT);
            addHandlers(pointerO);
            addHandlers(pointerX);
            addHandlers(touchrect);

            onResize();
        });

        function addHandlers(pointer) {
            window.addPointerDownHandler(pointer, function (event) {
                self.drag = true;
                switch (event.toElement.id) {
                    case "pointerTinner":
                        self.actualPointer = 0;
                        break;
                    case "pointerO":
                        self.actualPointer = 1;
                        break;
                    case "pointerXinner":
                        self.actualPointer = 2;
                        break;
                    case "pointerS":
                        self.actualPointer = 3;
                        break;
                    case "touchrect":
                        break;
                    default:
                        console.log("wo hast du geklickt?", event.toElement);
                }
                handleEvent(event);
            });

            window.addPointerMoveHandler(pointer, function (event) {
                if (self.drag) {
                    handleEvent(event);
                    event.preventDefault();
                }
            });

            window.addPointerUpHandler(pointer, function () {
                self.drag = false;
            });
        }

        function getPointFromColor(color) {
            var t, x, y, p = {};

            t = color.h * (Math.PI / 180);
            y = Math.sin(t) * self.cpradius * color.s;
            x = Math.cos(t) * self.cpradius * color.s;

            p.x = Math.round(x + self.refs.colorwheel.offsetLeft + self.cpradius);
            p.y = Math.round(self.cpradius - y + self.refs.colorwheel.offsetTop);

            return p;
        }

        function getColorFromPoint(p) {
            var h, t, s, x, y;
            x = p.x - self.refs.colorwheel.offsetLeft - self.cpradius;
            y = self.cpradius - p.y + self.refs.colorwheel.offsetTop;
            t = Math.atan2(y, x);
            h = (t * (180 / Math.PI) + 360) % 360;
            s = Math.min(Math.sqrt(x * x + y * y) / self.cpradius, 1);

            return new tinycolor({
                h: h,
                s: s,
                v: 1
            });
        }

        function getCirclePoint(x, y) {
            var p = {
                x: x,
                y: y
            },
                c = {
                    x: self.refs.colorwheel.offsetLeft + self.cpradius,
                    y: self.refs.colorwheel.offsetTop + self.cpradius
                },
                n;

            n = Math.sqrt(Math.pow((x - c.x), 2) + Math.pow((y - c.y), 2));

            if (n > self.cpradius) {
                p.x = (c.x) + self.cpradius * ((x - c.x) / n);
                p.y = (c.y) + self.cpradius * ((y - c.y) / n);
            }

            return p;
        }

        function updatePointer(id) {
            if (id < 0 || id > 3)
                return;

            var point = getPointFromColor(self.color[id].toHsv());
            switch (id) {
                case 0:
                    self.pointerTLeft = (point.x - 25);
                    self.pointerTTop = (point.y - 21.7);
                    break;
                case 1:
                    self.pointerOLeft = (point.x - 25);
                    self.pointerOTop = (point.y - 25);
                    break;
                case 2:
                    self.pointerXLeft = (point.x - 25);
                    self.pointerXTop = (point.y - 25);
                    break;
                case 3:
                    self.pointerSLeft = (point.x - 25);
                    self.pointerSTop = (point.y - 25);
                    break;
            }

            var c = new tinycolor({
                h: self.color[id].toHsv().h,
                s: 1 - self.color[id].toHsv().s,
                v: self.color[id].toHsv().v - 0.5
            });
            self.pointerTColor = (self.actualPointer == 0) ? c.toHexString() : new tinycolor("white");
            self.pointerOColor = (self.actualPointer == 1) ? c.toHexString() : new tinycolor("white");
            self.pointerXColor = (self.actualPointer == 2) ? c.toHexString() : new tinycolor("white");
            self.pointerSColor = (self.actualPointer == 3) ? c.toHexString() : new tinycolor("white");
        }

        function handleEvent(event) {
            var point, x, y;

            if (event.touches) {
                x = event.touches[0].clientX;
                y = event.touches[0].clientY;
            } else {
                x = event.clientX;
                y = event.clientY;
            }
            point = getCirclePoint(x, y);
            self.color[self.actualPointer] = getColorFromPoint(point);

            self.update();
            fireEvent();
        }

        function fireEvent() {
            var data = { color: self.color[self.actualPointer].toRgb(), pointer: self.actualPointer };
            self.trigger('color', data);
        }

        function imageLoaded(event) {
            self.cpradius = event.target.offsetWidth / 2;
            self.cpcenter = event.target.offsetLeft + self.cpradius;
            self.update();
        }
        self.imageLoaded = imageLoaded;

        window.addEventListener('resize', onResize);

        function onResize() {
            var attrW, attrH, side, w = self.root.clientWidth,
                h = self.root.clientHeight;

            attrW = self.refs.colorwheel.getAttribute('width');
            attrH = self.refs.colorwheel.getAttribute('height');
            side = attrW === 'auto' ? attrH : attrW;
            if (w > h) {
                if (attrH !== side) {
                    self.refs.colorwheel.setAttribute('height', side);
                    self.refs.colorwheel.setAttribute('width', 'auto');
                }
            } else if (attrW !== side) {
                self.refs.colorwheel.setAttribute('height', 'auto');
                self.refs.colorwheel.setAttribute('width', side);
            }

            self.cpradius = self.refs.colorwheel.offsetWidth / 2;
            self.cpcenter = self.refs.colorwheel.offsetLeft + self.cpradius;
            self.update();
        }

        function showMessage(text, type) {
            self.refs.message.className = type;
            self.refs.message.textContent = text;

            self.refs.message.parentElement.classList.remove('invisible');

            if (self.timer) {
                clearTimeout(self.timer);
            }
            self.timer = setTimeout(function () {
                self.refs.message.parentElement.classList.add('invisible');
                self.timer = null;
            }, 5000);
        }

    </script>

    <style>
        colorwheel {
            position: relative;
            -webkit-flex: 1;
            flex: 1;
        }

        #colorwheel {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: auto;
        }

        #pointerX,
        #pointerO,
        #pointerS,
        #pointerT {
            width: 50px;
            height: 50px;
            position: absolute;
            z-index: 2;
            left: calc(50% - 25px);
            top: calc(50% - 21.7px);
        }

        #pointerT {
            /* Dreieck */
            height: 43.4px;
        }

        #pointerTinner {
            fill: transparent;
            stroke: white;
            stroke-width: 2;
        }

        #pointerS {
            /* Viereck */
            border: 2px solid #FFFFFF;
            border-radius: 0;
        }

        #pointerO {
            /* Kreis */
            border: 2px solid #FFFFFF;
            border-radius: 25px;
        }

        #pointerX {
            /* Kreuz */
        }

        #pointerXinner {
            fill: transparent;
            stroke: #FFFFFF;
            stroke-width: 2;
        }
    </style>
</colorwheel>