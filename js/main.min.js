(function (riot$1) {
    'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var riot__default = /*#__PURE__*/_interopDefaultLegacy(riot$1);

    /* global riot */
    const NUS_SERVICE_UUID = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
    const NUS_RX_CHARACTERISTIC_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e';
    const NUS_TX_CHARACTERISTIC_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e';
    const DEVICE_NAME = 'PSX-Light';

    class Bluetooth {
        /**
         * @class Bluetooth
         * @constructs
         */
        constructor() {
            this.device = null;
            this.rx_characteristic = null;
            this.tx_characteristic = null;
            riot.observable(this);
        }

        /**
         * Connects to the PSX-Light
         */
        connect() {
            return new Promise((resolve, reject) => {
                if (this.device) {
                    if (this.device.gatt.connected) {
                        console.log("connected");
                        resolve();
                    } else {
                        console.log("connect");
                        this.device.gatt.connect()
                            .then(server => {
                                return server.getPrimaryServices();
                            }).then(services => {
                                let queue = Promise.resolve();
                                services.forEach(service => {
                                    queue = queue.then(_ => service.getCharacteristics().then(characteristics => {
                                        characteristics.forEach(characteristic => {
                                            if (characteristic.uuid == NUS_RX_CHARACTERISTIC_UUID) {
                                                this.rx_characteristic = characteristic;
                                            } else if (characteristic.uuid == NUS_TX_CHARACTERISTIC_UUID) {
                                                this.tx_characteristic = characteristic;
                                                this.tx_characteristic.startNotifications();
                                                // Set up event listener for when characteristic value changes.
                                                this.tx_characteristic.addEventListener('characteristicvaluechanged',
                                                    this.onReceive.bind(this));
                                            }
                                        });
                                    }));
                                });
                                return queue;
                            }).catch(error => reject(error));
                    }
                } else {
                    navigator.bluetooth.requestDevice({
                        filters: [{
                            services: [NUS_SERVICE_UUID]
                        }, {
                            name: DEVICE_NAME
                        }]
                    }).then(device => {
                        this.device = device;
                        this.device.addEventListener('gattserverdisconnected', this.onDisconnected.bind(this));
                        return device.gatt.connect();
                    }).then(server => {
                        return server.getPrimaryServices();
                    }).then(services => {
                        let queue = Promise.resolve();
                        services.forEach(service => {
                            queue = queue.then(_ => service.getCharacteristics().then(characteristics => {
                                characteristics.forEach(characteristic => {
                                    if (characteristic.uuid == NUS_RX_CHARACTERISTIC_UUID) {
                                        this.rx_characteristic = characteristic;
                                    } else if (characteristic.uuid == NUS_TX_CHARACTERISTIC_UUID) {
                                        this.tx_characteristic = characteristic;
                                        this.tx_characteristic.startNotifications();
                                        // Set up event listener for when characteristic value changes.
                                        this.tx_characteristic.addEventListener('characteristicvaluechanged',
                                            this.onReceive.bind(this));
                                    }
                                });
                            }));
                        });
                        return queue;
                    }).then(() => {
                        resolve();
                    }).catch(error => { reject(error); });
                }
            });
        }

        /**
         * Close bluetooth connection
         */
        disconnect() {
            if (this.device && this.device.gatt.connected) {
                this.device.gatt.disconnect();
                this.device = null;
            }
        }

        /**
         * Send data to the PSX-Light
         * @param {Array} data - Data to send
         */
        send(data) {
            return new Promise((resolve, reject) => {
                if (!this.device || !this.device.gatt.connected || !this.rx_characteristic) {
                    reject('Not connected');
                    return;
                }

                this.rx_characteristic.writeValue(new Uint8Array(data))
                    .then(() => {
                        resolve();
                    }).catch(error => {
                        reject(error);
                    });
            });
        }

        /**
         * @private
         */
        onDisconnected() {
            this.rx_characteristic = null;
            this.tx_characteristic = null;
            this.trigger('disconnect');
        }

        onReceive(event) {
            this.trigger('receive', event.currentTarget.value.buffer);
        }
    }

    riot__default["default"].tag2('app', '<div class="work"> <div class="container"> <color-tab ref="colortab" class="contentarea" color="#FFFFFF"> </color-tab> </div> <div class="wrapper_msg invisible"> <div ref="message"></div> </div> </div> <div class="footer"> <div each="{buttons}" class="button {selected: activeTab === type}" onclick="{footerButtonClick}"> <div class="icon">{icon}</div> <div class="title">{title}</div> </div> </div> <connect-dialog show="{showConnect}" ref="connectdialog"></connect-dialog>', 'app { height: 100%; width: 100%; display: -webkit-flex; -webkit-flex-direction: column; -webkit-flex-wrap: nowrap; display: flex; flex-direction: column; flex-wrap: nowrap; background-color: #2C2C2C; min-width: 320px; min-height: 460px; } .work { -webkit-flex: 1; flex: 1; position: relative; overflow: hidden; } .container { position: absolute; left: 0; top: 0; bottom: 0; width: 100%; display: flex; display: -webkit-flex; -webkit-transition: left 0.5s ease-in-out; transition: left 0.5s ease-in-out; } .contentarea { width: 100%; height: 100%; overflow-y: overlay; -ms-overflow-y: auto; -ms-overflow-style: -ms-autohiding-scrollbar; position: relative; -webkit-overflow-scrolling: touch; } .info { font-size: 16px; position: absolute; top: 50%; width: 100%; text-align: center; } .footer { border-top: 1px solid #919F9F; display: -webkit-flex; -webkit-justify-content: space-around; display: flex; justify-content: space-around; } .footer .button:active, .footer .button.selected { color: #FFFFFF; } .footer .button { width: 100%; text-align: center; position: relative; padding: 5px; } .footer .button .icon { font-size: 25px; margin-top: 8px; } .footer .button .title { font-size: 12px; margin-top: 8px; margin-bottom: 8px; } .wrapper_msg { position: absolute; bottom: 5px; width: 100%; display: -webkit-flex; display: flex; visibility: visible; opacity: 1; -webkit-transition: opacity 0.2s linear; transition: opacity 0.2s linear; justify-content: center; } .error { background-color: #D70000; color: #FFFFFF; } .status { background-color: #00A200; color: #FFFFFF; } .wrapper_msg>div { padding: 5px 10px; font-size: 12px; font-weight: bold; } .contentarea { display: flex; flex-direction: column; }', '', function(opts) {
            var self = this;
            var ble = new Bluetooth();
            self.showConnect = true;
            self.currentColor = {
                r: 255,
                g: 255,
                b: 255
            };
            self.brightness = 0;
            self.currentDigit = 0;

            self.buttons = [{
                title: 'Color',
                icon: 'b',
                type: 'color'
            } ];
            self.activeTab = 'color';

            ble.on('disconnect', () => {
                stopConnectionTimer();
                self.showConnect = true;
                self.update();
            });

            ble.on('receive', (data) => {
                var buf = new Uint8Array(data);
                for (let i = 0; i < buf.length; i++) {
                    switch (buf[i]) {
                        case 0xB0:
                        case 0xB1:
                        case 0xB2:
                        case 0xB3:
                            var color = new tinycolor({ r: buf[i + 1], g: buf[i + 2], b: buf[i + 3] });
                            self.refs.colortab.setColor(buf[i] - 0xb0, color);
                            i += 3;
                            break;
                        case 0xB4:
                            self.refs.colortab.setBrightness(buf[i + 1] / 256);
                            i += 1;
                            break;
                        default:
                            console.log("received", buf[i]);
                    }
                }
            });

            self.on('mount', () => {
                self.refs.colortab.on('brightness', data => {
                    self.brightness = data.brightness;
                    sendBrightnessToPSXLight();
                });

                self.refs.colortab.on('color', data => {
                    self.currentColor = data.color;
                    self.currentDigit = data.pointer;
                    sendValuesToPSXLight();
                });

                self.refs.connectdialog.on('connect', () => {
                    ble.connect()
                        .then(() => {
                            startConnectionTimer();
                            self.showConnect = false;
                            self.update();
                            showMessage('connected', 'status');
                            ble.send([0xA0, 1])
                                .catch(error => {
                                    self.sending = false;
                                    showMessage(error, 'error');
                                });
                        }).catch(error => showMessage(error, 'error'));
                });
            });

            self.footerButtonClick = (event) => {
                self.update({
                    activeTab: event.item.type
                });
                var area, index;
                area = self.refs[event.item.type + 'tab'].root;
                index = area.offsetLeft / area.clientWidth;
                area.parentElement.style.left = (-index * 100) + '%';
            };

            function stopConnectionTimer() {
                if (self.connectionTimer) {
                    clearTimeout(self.connectionTimer);
                    self.connectionTimer = null;
                }
            }
            function resetConnectionTimer() {
                stopConnectionTimer();
                startConnectionTimer();
            }
            function startConnectionTimer() {
                self.connectionTimer = setTimeout(() => {
                    stopConnectionTimer();
                    self.showConnect = true;
                    self.update();
                    ble.send([0xA0, 0x00])
                        .then(() => {
                            ble.disconnect();
                            showMessage("disconnected", 'info');
                        }).catch(error => {
                            self.sending = false;
                            showMessage(error, 'error');
                        });
                }, 60000);
            }
            function showMessage(text, type) {
                self.refs.message.className = type;
                self.refs.message.textContent = text;

                self.refs.message.parentElement.classList.remove('invisible');

                if (self.timer) {
                    clearTimeout(self.timer);
                }
                self.timer = setTimeout(function () {
                    self.refs.message.parentElement.classList.add('invisible');
                    self.timer = null;
                }, 5000);
            }

            function sendBrightnessToPSXLight() {
                var setBrightness = [0xA2, self.brightness * 0xFF];

                if (!self.sending) {
                    resetConnectionTimer();
                    self.sending = true;
                    ble.send(setBrightness)
                        .then(() => {
                            self.sending = false;
                        }).catch(error => {
                            self.sending = false;
                            showMessage(error, 'error');
                        });
                }
            }

            function sendValuesToPSXLight() {
                var setRGB = [0xA1, self.currentDigit, self.currentColor.r, self.currentColor.g, self.currentColor.b];

                if (!self.sending) {
                    resetConnectionTimer();
                    self.sending = true;
                    ble.send(setRGB)
                        .then(() => {
                            self.sending = false;
                        }).catch(error => {
                            self.sending = false;
                            showMessage(error, 'error');
                        });
                }
            }
    });

    riot__default["default"].tag2('color-tab', '<colorwheel ref="colorwheel" color="{color}"></colorwheel> <slider ref="slider" min="0" max="1" step="0.02" value="{brightness}"> </slider> <div id="buttonctrl"> </div>', '#buttonctrl { display: -webkit-flex; -webkit-justify-content: space-between; -webkit-align-items: flex-end; display: flex; justify-content: space-between; align-items: flex-end; margin: 10px auto 35px auto; } #buttonctrl>.icon { font-size: 27px; line-height: 100%; padding: 0 20px; } #buttonctrl>.icon:active { color: #FFFFFF; } color-tab slider { width: 70%; margin: 10px auto; height: 20px; align-self: center; } color-tab slider .track { width: 100%; height: 100%; background-image: linear-gradient(to right, #000000 0%, #FFFFFF 100%); } color-tab slider .thumb { background: transparent; border: 3px solid rgba(255, 255, 255, 1.0); width: 14px; border-radius: 4px; height: 28px; position: absolute; top: -4px; margin-left: -7px; }', '', function(opts) {
            var self = this;
            self.color = new tinycolor(opts.color || {
                r: 0xff,
                g: 0xff,
                b: 0xff
            });
            self.brightness = 0;
            self.actualPointer = -1;

            self.on('mount', function () {
                self.refs.slider.on('brightness', function (value) {
                    self.brightness = value;
                    fireBrightnessEvent();
                });

                self.refs.colorwheel.on('color', function (value) {
                    self.color = new tinycolor(value.color);
                    self.actualPointer = value.pointer;
                    self.update();
                    fireColorEvent();
                });

                self.update();
            });

            self.setColor = function setColor(pointer, color) {
                self.refs.colorwheel.setColor(pointer, color);
            };

            self.setBrightness = function setBrightness(brightness) {
                self.brightness = brightness;
                self.refs.slider.setValue(brightness);
            };

            function getCurrentColor() {
                var rgb = self.color.toRgb();
                return rgb;
            }

            function fireBrightnessEvent() {
                var data = { brightness: self.brightness };
                self.trigger('brightness', data);
            }

            function fireColorEvent() {
                var data = { color: getCurrentColor(), pointer: self.actualPointer };
                self.trigger('color', data);
            }
    });

    riot__default["default"].tag2('colorwheel', '<img id="colorwheel" ref="colorwheel" src="res/colorwheel.png" width="auto" height="90%" onload="{imageLoaded}"> <div class="touchrect" id="touchrect"></div> <div id="pointerT" ref="pointerT" riot-style="left: {pointerTLeft}px; top: {pointerTTop}px;"> <svg height="50" width="50"> <polygon id="pointerTinner" points="25,0 0,43.4 50,43.4" riot-style="stroke: {pointerTColor}"></polygon> </svg> </div> <div id="pointerO" ref="pointerO" riot-style="left: {pointerOLeft}px; top: {pointerOTop}px; border-color: {pointerOColor};"> </div> <div id="pointerX" ref="pointerX" riot-style="left: {pointerXLeft}px; top: {pointerXTop}px;"> <svg id="pointerXinner" height="50" width="50"> <polygon id="pointerXinner" points="10,0 0,10 15,25 0,40 10,50 25,35 40,50 50,40 35,25 50,10 40,0 25,15" riot-style="stroke: {pointerXColor};"></polygon> </svg> </div> <div id="pointerS" ref="pointerS" riot-style="left: {pointerSLeft}px; top: {pointerSTop}px; border-color: {pointerSColor};"> </div> <div class="wrapper_msg invisible"> <div ref="message"></div> </div>', 'colorwheel { position: relative; -webkit-flex: 1; flex: 1; } #colorwheel { position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto; } #pointerX, #pointerO, #pointerS, #pointerT { width: 50px; height: 50px; position: absolute; z-index: 2; left: calc(50% - 25px); top: calc(50% - 21.7px); } #pointerT { height: 43.4px; } #pointerTinner { fill: transparent; stroke: white; stroke-width: 2; } #pointerS { border: 2px solid #FFFFFF; border-radius: 0; } #pointerO { border: 2px solid #FFFFFF; border-radius: 25px; } #pointerX { } #pointerXinner { fill: transparent; stroke: #FFFFFF; stroke-width: 2; }', '', function(opts) {
            var self = this;
            self.color = new Array(4).fill(new tinycolor(opts.color));
            self.actualPointer = -1;

            self.setColor = function (pointer, color) {
                self.color[pointer] = new tinycolor(color);
                if (self.isMounted) {
                    self.update();
                }
            };

            self.on('update', function () {
                for (var i = 0; i <= 3; i++)
                    updatePointer(i);
            });

            self.on('mount', function () {
                var pointerS = self.root.querySelector('#pointerS');
                var pointerT = self.root.querySelector('#pointerTinner');
                var pointerO = self.root.querySelector('#pointerO');
                var pointerX = self.root.querySelector('#pointerXinner');
                var touchrect = self.root.querySelector('.touchrect');
                addHandlers(pointerS);
                addHandlers(pointerT);
                addHandlers(pointerO);
                addHandlers(pointerX);
                addHandlers(touchrect);

                onResize();
            });

            function addHandlers(pointer) {
                window.addPointerDownHandler(pointer, function (event) {
                    self.drag = true;
                    switch (event.toElement.id) {
                        case "pointerTinner":
                            self.actualPointer = 0;
                            break;
                        case "pointerO":
                            self.actualPointer = 1;
                            break;
                        case "pointerXinner":
                            self.actualPointer = 2;
                            break;
                        case "pointerS":
                            self.actualPointer = 3;
                            break;
                        case "touchrect":
                            break;
                        default:
                            console.log("wo hast du geklickt?", event.toElement);
                    }
                    handleEvent(event);
                });

                window.addPointerMoveHandler(pointer, function (event) {
                    if (self.drag) {
                        handleEvent(event);
                        event.preventDefault();
                    }
                });

                window.addPointerUpHandler(pointer, function () {
                    self.drag = false;
                });
            }

            function getPointFromColor(color) {
                var t, x, y, p = {};

                t = color.h * (Math.PI / 180);
                y = Math.sin(t) * self.cpradius * color.s;
                x = Math.cos(t) * self.cpradius * color.s;

                p.x = Math.round(x + self.refs.colorwheel.offsetLeft + self.cpradius);
                p.y = Math.round(self.cpradius - y + self.refs.colorwheel.offsetTop);

                return p;
            }

            function getColorFromPoint(p) {
                var h, t, s, x, y;
                x = p.x - self.refs.colorwheel.offsetLeft - self.cpradius;
                y = self.cpradius - p.y + self.refs.colorwheel.offsetTop;
                t = Math.atan2(y, x);
                h = (t * (180 / Math.PI) + 360) % 360;
                s = Math.min(Math.sqrt(x * x + y * y) / self.cpradius, 1);

                return new tinycolor({
                    h: h,
                    s: s,
                    v: 1
                });
            }

            function getCirclePoint(x, y) {
                var p = {
                    x: x,
                    y: y
                },
                    c = {
                        x: self.refs.colorwheel.offsetLeft + self.cpradius,
                        y: self.refs.colorwheel.offsetTop + self.cpradius
                    },
                    n;

                n = Math.sqrt(Math.pow((x - c.x), 2) + Math.pow((y - c.y), 2));

                if (n > self.cpradius) {
                    p.x = (c.x) + self.cpradius * ((x - c.x) / n);
                    p.y = (c.y) + self.cpradius * ((y - c.y) / n);
                }

                return p;
            }

            function updatePointer(id) {
                if (id < 0 || id > 3)
                    return;

                var point = getPointFromColor(self.color[id].toHsv());
                switch (id) {
                    case 0:
                        self.pointerTLeft = (point.x - 25);
                        self.pointerTTop = (point.y - 21.7);
                        break;
                    case 1:
                        self.pointerOLeft = (point.x - 25);
                        self.pointerOTop = (point.y - 25);
                        break;
                    case 2:
                        self.pointerXLeft = (point.x - 25);
                        self.pointerXTop = (point.y - 25);
                        break;
                    case 3:
                        self.pointerSLeft = (point.x - 25);
                        self.pointerSTop = (point.y - 25);
                        break;
                }

                var c = new tinycolor({
                    h: self.color[id].toHsv().h,
                    s: 1 - self.color[id].toHsv().s,
                    v: self.color[id].toHsv().v - 0.5
                });
                self.pointerTColor = (self.actualPointer == 0) ? c.toHexString() : new tinycolor("white");
                self.pointerOColor = (self.actualPointer == 1) ? c.toHexString() : new tinycolor("white");
                self.pointerXColor = (self.actualPointer == 2) ? c.toHexString() : new tinycolor("white");
                self.pointerSColor = (self.actualPointer == 3) ? c.toHexString() : new tinycolor("white");
            }

            function handleEvent(event) {
                var point, x, y;

                if (event.touches) {
                    x = event.touches[0].clientX;
                    y = event.touches[0].clientY;
                } else {
                    x = event.clientX;
                    y = event.clientY;
                }
                point = getCirclePoint(x, y);
                self.color[self.actualPointer] = getColorFromPoint(point);

                self.update();
                fireEvent();
            }

            function fireEvent() {
                var data = { color: self.color[self.actualPointer].toRgb(), pointer: self.actualPointer };
                self.trigger('color', data);
            }

            function imageLoaded(event) {
                self.cpradius = event.target.offsetWidth / 2;
                self.cpcenter = event.target.offsetLeft + self.cpradius;
                self.update();
            }
            self.imageLoaded = imageLoaded;

            window.addEventListener('resize', onResize);

            function onResize() {
                var attrW, attrH, side, w = self.root.clientWidth,
                    h = self.root.clientHeight;

                attrW = self.refs.colorwheel.getAttribute('width');
                attrH = self.refs.colorwheel.getAttribute('height');
                side = attrW === 'auto' ? attrH : attrW;
                if (w > h) {
                    if (attrH !== side) {
                        self.refs.colorwheel.setAttribute('height', side);
                        self.refs.colorwheel.setAttribute('width', 'auto');
                    }
                } else if (attrW !== side) {
                    self.refs.colorwheel.setAttribute('height', 'auto');
                    self.refs.colorwheel.setAttribute('width', side);
                }

                self.cpradius = self.refs.colorwheel.offsetWidth / 2;
                self.cpcenter = self.refs.colorwheel.offsetLeft + self.cpradius;
                self.update();
            }

    });

    riot__default["default"].tag2('slider', '<div class="track"></div> <div class="thumb" riot-style="left: {((value - min) * 100 / (max - min))}%"> </div>', 'slider { position: relative; margin-left: 20px; margin-right: 20px; } .thumb { box-sizing: border-box; border-radius: 10px; height: 20px; width: 20px; border: 2px solid #BDC3C7; background-color: #FFFFFF; position: absolute; top: -8px; margin-left: -10px; } .track { border-radius: 4px; height: 4px; border: 1px solid #BDC3C7; background-color: #FFFFFF; }', '', function(opts) {
            var self = this;
            self.min = opts.min || 0;
            self.max = opts.max || 100;
            self.value = opts.value || 0;
            self.step = opts.step || 1;

            self.setValue = function (value) {
                self.value = value || 0;
                self.update();
            };

            function handleEvent(event) {
                var x, left, ratio, value, steppedValue;
                if (event.touches) {
                    x = event.touches[0].clientX;
                } else {
                    x = event.clientX;
                }

                left = x - self.root.getBoundingClientRect().left;
                ratio = left / self.root.offsetWidth;
                value = (self.max - self.min) * ratio;

                steppedValue = (value - self.min) % self.step;
                if (steppedValue <= self.step / 2) {
                    value = value - steppedValue;
                } else {
                    value = value + (self.step - steppedValue);
                }

                value = Math.max(value, self.min);
                value = Math.min(value, self.max);
                self.value = value;
                self.update();
                self.trigger('brightness', value);
            }

            function pointerMoveEventHandler(event) {
                if (self.drag) {
                    handleEvent(event);
                    event.preventDefault();
                }
            }

            function pointerUpEventHandler() {
                self.drag = false;
                self.update();
                window.removePointerMoveHandler(document, pointerMoveEventHandler);
                window.removePointerUpHandler(document, pointerUpEventHandler);
            }

            window.addPointerDownHandler(self.root, function (event) {
                self.drag = true;
                handleEvent(event);
                window.addPointerMoveHandler(document, pointerMoveEventHandler);
                window.addPointerUpHandler(document, pointerUpEventHandler);
            });
    });

    riot__default["default"].tag2('footer-button', '<div each="{buttons}" class="button {selected: activeTab === type}" onclick="{footerButtonClick}"> <div class="icon">{this.root.innerHTML = icon}</div> <div class="title">{title}</div> </div> <div class="button {selected: this.selected === true}"> </div>', '', '', function(opts) {
            var tag = this;
            tag.icon = opts.icon;
            tag.title = opts.title;
            tag.selected = opts.selected;
    });

    riot__default["default"].tag2('connect-dialog', '<div class="content"> <p>Press the button to scan for PSX-Light and connect to it</p> <button onclick="{onConnectButtonClick}">Scan & Connect</button> </div>', 'connect-dialog { display: block; z-index: 10; position: fixed; left: 0; right: 0; top: 0; bottom: 0; background-color: rgba(255, 255, 255, 0.7); text-align: center; } connect-dialog:before { content: \'\'; display: inline-block; height: 100%; vertical-align: middle; } .content { display: inline-block; vertical-align: middle; background-color: gray; min-width: 200px; border-radius: 6px; padding: 20px; margin: 0 10px; } button { background-color: red; border: none; color: white; padding: 10px 20px; border-radius: 5px; font-size: 1em; outline: none; } button:active { background-color: darkred; } p { color: white; margin-top: 0; }', '', function(opts) {
            var self = this;

            self.onConnectButtonClick = function () {
                self.trigger('connect');
            };
    });

    /* global riot */

    riot.mount('*');

})(riot);
